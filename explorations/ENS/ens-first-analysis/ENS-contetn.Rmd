---
always_allow_html: yes
output:
  pdf_document:
    toc: yes
  html_document:
    df_print: paged
    includes:
      in_header: header.html
    toc: yes
---



```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(fig.align = 'center') 

```

## Load data set and packages

```{r load.data, message=FALSE, warning=FALSE, cache=TRUE, cache.lazy=FALSE}
source('ens-init.R')

```

```{r message=FALSE, warning=FALSE, include=FALSE}
require(readr)
require(dplyr)
require(ggplot2)
require(tidyr)
require(sparkline)
require(ggridges)
require(DT)
require(lubridate)
```

- We've loaded an articulated dataset generated by QuickBlocks. Included in the data set is any transaction or trace from May '17 - Dec. '17 that mentions the ENS-Registry `0x6090a6e47849629b7245dfa1ca21d94cd15878ef` contract address.
- Function arguments are "exploded" into columns.
- Articulated data for ENS-EthNameService `0x314159265dD8dbb310642f98f50C066173C1259b` is yet to be integrated.



## I. ENS-Registry contract: Top 10 most active users ("Superusers"), May-Dec '17

First, we analyze activity from the top 10 most active addresses ranked by by non-error ENS transactions during this ~8 month period. [Reading](https://medium.com/@Vlad_Zamfir/my-take-on-blockchain-name-registries-30ce6a680dfb) [some](https://discuss.ens.domains/t/charter-for-the-permanent-registrar-working-group/584) [threads](https://medium.com/the-ethereum-name-service/state-of-the-ens-week-3-d34c639964c0) and also the original [EIPs](https://github.com/ethereum/EIPs/issues/162), it's clear that name squatting is a priority concern for the ENS designers. From an ENS EIP:

> In order to maximize utility and adoption of a new namespace, the registrar should mitigate speculation and "name squatting", however the best approach for mitigation is unclear. Thus an "initial" registrar is proposed, which implements a simple approach to name allocation. [...] This Initial Registrar contract will be replaced with a permanent registrar contract. The Permanent Registrar will increase the available namespace, and incorporate lessons learned from the performance of the Initial Registrar. 
-- maurelian, [EIP #162](https://github.com/ethereum/EIPs/issues/162)

For brevity's sake, we'll call each address a "user," and use the name "superuser" to mean an address with contract interaction count in the top 10.


### i. ENS-Registry contract: Superuser interaction count

```{r include=FALSE}
top.10 <- base.exploded %>%
  filter(to == special.addr$`Contract: ENS-Registrar`,
         is_error == 0,
         traceid == 0) %>%
  group_by(from) %>%
  summarize(n = n()) %>%
  arrange(desc(n)) %>%
  top_n(10) %>%
  select(from) %>%
  unname() %>%
  unlist()
```

#### Superuser vs. non-superuser contract interaction count

```{r, message=FALSE}
base.exploded %>%
  filter(to == special.addr$`Contract: ENS-Registrar`,
         is_error == 0,
         traceid == 0) %>%
  mutate(is.superuser = from%in% top.10) %>%
  group_by(is.superuser) %>%
  summarize(n = n()) %>%
  mutate(pct = n/sum(n))
```

#### Superuser contract interaction detail

```{r, message=FALSE}
base.exploded %>%
  filter(to == special.addr$`Contract: ENS-Registrar`,
         is_error == 0,
         traceid == 0,
         from %in% top.10) %>%
  group_by(from, fn.name) %>%
  summarize(n = n()) %>%
  spread(key = 'fn.name', val = 'n') %>%
    mutate_all(funs(ifelse(is.na(.), 0, .))) %>%
  mutate(auction.starts = startAuction + startAuctions + startAuctionsAndBid,
         bids = startAuctionsAndBid + newBid) %>%
  select(auction.starts, bids, unsealBid, finalizeAuction)
```


Interpretation:

Despite their relatively large activity numbers, some superuser addresses never called `finalizeAuction()` within the timeframe of this analysis. From the [ENS docs](https://media.readthedocs.org/pdf/ens/latest/ens.pdf):

> Once the auction has completed, it must be finalized in order for the name to be assigned to the winning bidder. 
Only the winning bidder can do this.

If a user can afford to delay her/his `finalizeAuction()` calls for months, it reinforces a suspicion of name squatting.



### ii. ENS-Registry contract: Superuser interaction timelines

#### Simple interaction timeline per superuser

```{r paged.print=TRUE, warning=FALSE, fig.width = 10}
base.exploded %>%
  filter(to == special.addr$`Contract: ENS-Registrar`,
         from %in% top.10,
         is_error == 0,
         traceid == 0) %>%
  ggplot(aes(x=date, y=fn.name, color=from)) +
  geom_point() +
  facet_wrap(facets = 'from') +
  scale_y_discrete(limits=rev(c('startAuction', 'startAuctions', 'startAuctionsAndBid', 'newBid', 'unsealBid', 'finalizeAuction', 'transfer', 'invalidateName'))) +
  theme(legend.position="none")
```



#### Activity timeline showing relative interaction density per superuser

```{r message=FALSE, warning=FALSE, include=FALSE}

# BUT FIRST, we customize the colors so we don't need a legend...

gg_color_hue <- function(n) {
  hues = seq(15, 375, length = n + 1)
  hcl(h = hues, l = 65, c = 100)[1:n]
}

shifter <- function(x, n = 1) {
  if (n == 0) x else c(tail(x, -n), head(x, n))
}

custom <- shifter(rev(gg_color_hue(8)), 5)
quickfix <- c(custom[2], custom[5])
custom[2] <- quickfix[2]
custom[5] <- quickfix[1]
```

```{r message=FALSE, warning=FALSE, fig.width=10}
base.exploded %>%
  filter(to == special.addr$`Contract: ENS-Registrar`,
         from %in% top.10,
         is_error == 0,
         traceid == 0) %>%
  mutate(date = as.Date(date)) %>%
  group_by(date, from, fn.name) %>%
  summarize(n = n()) %>%
  ggplot(aes(x=date, y=fn.name, fill=fn.name)) +
  geom_density_ridges() +
  facet_wrap(facets = 'from') +
  theme(axis.text.y = element_text(colour = custom)) +
  scale_y_discrete(limits=rev(c('startAuction', 'startAuctions', 'startAuctionsAndBid', 'newBid', 'unsealBid', 'finalizeAuction', 'transfer', 'invalidateName'))) +
  theme(legend.position="none")
```




## II. ENS-Registry contract: Simple non-error auction action counts, all addresses,  May-Dec '17

### i. Non-error action counts per month

```{r tx.per.month, message=FALSE, warning=FALSE}
base.exploded %>%
  filter(to == special.addr$`Contract: ENS-Registrar`,
         is_error == 0,
         traceid == 0) %>% 
  mutate(month = format(date, '%Y-%m')) %>% 
  group_by(month, fn.name) %>% 
  summarize(n = n()) %>%
  spread(key = 'fn.name', value = 'n') %>%
  mutate_each(funs(ifelse(is.na(.), 0, .))) %>%
  mutate(bids = newBid + startAuctionsAndBid,
         start.auction = startAuction + startAuctions + startAuctionsAndBid) %>%
  select(bids, start.auction, unsealBid, finalizeAuction)
```

### ii. Median, mean, and standard deviation of # bids unsealed per auction

```{r for.sparklines, message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE}
means <- base.exploded %>%
  filter(to == special.addr$`Contract: ENS-Registrar`,
         is_error == 0,
         traceid == 0,
         fn.name == 'unsealBid') %>%
  mutate(month = format(date, '%Y-%m')) %>%
  group_by(month, args1) %>% 
  summarize(n = n()) %>%
  summarize(mean = mean(n), variance = var(n))
```

```{r}
base.exploded %>%
  filter(to == special.addr$`Contract: ENS-Registrar`,
         is_error == 0,
         traceid == 0,
         fn.name == 'unsealBid') %>%
  mutate(month = format(date, '%Y-%m')) %>%
  group_by(month, args1) %>% 
  summarize(n = n()) %>%
  summarize(median = median(n), mean = mean(n), sd = sd(n))
```


Interpretation: 

Over this timeframe, there was initially more competition over names judging from the mean `r sparkline(means$mean)` and variance `r sparkline(means$variance)` of # unsealed bids per auction. We expect that this can be explained by competitive early known name bidding. This is probably why Nick Johnson was motivated to separate out the two categories of names in his analyses. We can explore this by scraping known names from etherscan and comparing them to a group comprised of unknown namehashes (TBD).



### iii. Proportion of bids made vs. bids unsealed: addresses with >5 bids

We read a lot about users who missed the reveal on their bids. What's the distribution of the proportion between bids placed and bids revealed during the analysis timeframe? We'll look at addresses who placed at least 5 bids.

```{r message=FALSE, fig.height=2}
  base.exploded %>%
    filter(to == special.addr$`Contract: ENS-Registrar`,
           is_error == 0,
           traceid == 0) %>%
    group_by(from, fn.name) %>%
    summarize(n = n()) %>%
    spread(key = c('fn.name'), value = c('n')) %>%
    mutate_all(funs(ifelse(is.na(.), 0, .))) %>%
    mutate(bid = newBid + startAuctionsAndBid,
           start.auction = startAuction + startAuctions + startAuctionsAndBid) %>%
    mutate(made.vs.unsealed = (bid - unsealBid) / bid) %>%
    select(bid, unsealBid, finalizeAuction, made.vs.unsealed) %>%
    filter(bid > 5) %>%
    ggplot(aes(x = made.vs.unsealed)) +
    geom_histogram() +
    xlab('Proportion per user of bids made to bids unsealed (no bids left sealed = 0)')
```

```{r message=FALSE}
  base.exploded %>%
    filter(to == special.addr$`Contract: ENS-Registrar`,
           is_error == 0,
           traceid == 0) %>%
    group_by(from, fn.name) %>%
    summarize(n = n()) %>%
    spread(key = c('fn.name'), value = c('n')) %>%
    mutate_all(funs(ifelse(is.na(.), 0, .))) %>%
    mutate(bid = newBid + startAuctionsAndBid,
           start.auction = startAuction + startAuctions + startAuctionsAndBid) %>%
    mutate(made.vs.unsealed = (bid - unsealBid) / bid) %>%
    select(bid, unsealBid, finalizeAuction, made.vs.unsealed) %>%
    filter(bid > 5) %>%
    arrange(desc(made.vs.unsealed)) %>%
    mutate(made.vs.unsealed = format(made.vs.unsealed, digits=2, scientific=FALSE)) %>%
  rename('proportion' = made.vs.unsealed)
```

Interpretation:



## III. Other function calls and their error rates

### i. `releaseDeed()`

```{r include=FALSE}
releaseDeedCount <- base.exploded %>%
  filter(traceid == 0,
         fn.name == 'releaseDeed')%>%
  group_by(is_error) %>%
  summarize(n=n()) %>% select(n) %>% unlist() %>% unname()
```

Release deed was called `r releaseDeedCount` times, all of which were errors. We have an explanation: deeds can't be released until a year after their initial possession date.

Timeline of calls:

```{r fig.height=1, fig.width=8}
base.exploded %>%
  filter(traceid == 0,
         fn.name == 'releaseDeed') %>%
  mutate(is_error = as.character(is_error)) %>%
  ggplot(aes(x=date, y=fn.name, color=is_error)) +
  geom_point()
```

### ii. `invalidateName()`

```{r include=FALSE}
invalidateName <- base.exploded %>%
  filter(traceid == 0,
         fn.name == 'invalidateName')%>%
  group_by(is_error) %>%
  summarize(n=n()) %>% select(n) %>% unlist() %>% unname()
```

`invalidateName()` was called `r sum(invalidateName)` times, `r invalidateName[1]` were successful and `r invalidateName[2]` were errors.

Timeline of calls:

```{r fig.height=1, fig.width=8}
base.exploded %>%
  filter(traceid == 0,
         fn.name == 'invalidateName') %>%
  mutate(is_error = as.character(is_error)) %>%
  ggplot(aes(x=date, y=fn.name, color=is_error)) +
  geom_point()
```


## About QuickBlocks

QuickBlocks is a collection of software libraries, applications, and command-line tools designed to give you quick access to the data provided by an Ethereum node.

In a manner very similar to the way web3.js works, QuickBlocks sits between a locally running Ethereum node (or any node, local or remote, for that matter), and delivers the Ethereum data to your application. There are two significant advantages to using QuickBlocks over web3.js First, QuickBlocks caches the data locally which means that time-to-data is severely decreased. Secondly, if you provide QuickBlocks with the ABI to your smart contract, it can deliver what we call articulated data. By this we mean that instead of returning data in the language of the Ethereum node (blocks and transactions and receipts and logs), we return data in the language of your smart contract (transfers and votes and proposals and expenditures). This eases the burden on your dApp developers.

Whereas the web3.js library delivers nearly identical data as is retrieved from the RPC interface, making it difficult for any but the most well versed in the data to easily use it, QuickBlocks stands between the node and your application improving the data significantly in two ways: (1) it’s much faster, and (2) it’s translated into the language of the smart contract. See [quickblocks.io](https://quickblocks.io) for more detail.

View our open-source library at [https://github.com/Great-Hill-Corporation/quickblocks](https://github.com/Great-Hill-Corporation/quickblocks).
